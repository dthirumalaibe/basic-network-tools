#!/usr/bin/python

###############################################################################
# File: IPv6Address_Test.py
# Author: Nicholas Russo
# Description: This file includes a class that represents a test case specific
#  to IPv6 addressing. Each of the methods defined in IPv6Address are tested
#  here. This is meant to serve as a regression test for that class.
###############################################################################

from NetAddress_Test import NetAddress_Test
from IPv6Address import IPv6Address
import unittest

# Defines an IPv6 address test case, inheriting from NetAddress test case
class IPv6Address_Test( NetAddress_Test ):

    # Invokes the static method defined in NetAddress_Test to build a test suite
    #  Effectively, this just passes up the class name to the parent.
    @staticmethod
    def buildTestSuite():
        return NetAddress_Test.buildTestSuite( IPv6Address_Test )
    
    # Implements the abstract method defined in NetAddress_Test to add a pool
    #  of IPv6 addresses for testing.
    def populateNetAddressList(self):
        self.getNetAddressList().append( 
        IPv6Address([0x20,0x1,0xdb,0x8,0,0,0,0,0,0,0,0,0,0,0,1]) )
        self.getNetAddressList().append( 
        IPv6Address([0xff,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1]) )
        self.getNetAddressList().append( 
        IPv6Address([0xff,0,0,0,0,0,0,0,0,0,0,0,0,0xa,0xb,0xc]) )
        
    # Tests the isUnicast() function within the IPv6Address class.
    #  The method under test returns true if the IPv6 address is unicast.
    def test_isUnicast(self):
        for ip in self.getNetAddressList():
            if( ip.getOctet(1) >= 0x1 and ip.getOctet(1) <= 0xfe ):
                self.assertTrue( ip.isUnicast() )
            else:
                self.assertFalse( ip.isUnicast() )

    # Tests the isMulticast() function within the IPv4Address class
    #  The method under test returns true if the IPv4 address is multicast.
    def test_isMulticast(self):
        for ip in self.getNetAddressList():
            if( ip.getOctet(1) == 0xff ):
                self.assertTrue( ip.isMulticast() )
            else:
                self.assertFalse( ip.isMulticast() )
    
    # Tests the toString() function within the IPv6Address class
    #  The method under test returns a string representation of the IPv6
    #  address in fully extended EUI format 
    #  (xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx)
    def test_toString(self):
        for ip in self.getNetAddressList():
            
            # Convert the IP address to a string, then split it using
            #  the colon ":" character as a delimiter. The result is
            #  a list of 8 double-octets (16 octets total)
            ipString = ip.toString()
            ipStringOctets = ipString.split(":")      
            
            # There should be exactly 8 double-octets in the address
            self.assertTrue( len( ipStringOctets ) == 8 )
            
            # Iterate over all of the octets generated by toString()
            #  that were split apart. Compare those to the actual integer
            #  octets within the IP address; everything should match
            i = 1
            for ipStringOctet in ipStringOctets:
                
                # Break the double-octet into two individual octets 
                #  (e.g. split "2001" into "20" and "01")
                #  Then, convert the first and second halves into hex integers
                firstHalfHex = int( ipStringOctet[:2], 16 )
                secondHalfHex = int( ipStringOctet[2:], 16 )
                
                # Ensure the parsed octets match the values in memory
                self.assertTrue( firstHalfHex == ip.getOctet(i) )
                self.assertTrue( secondHalfHex == ip.getOctet(i+1) )
                
                # Increment the iterator by 2 since two assertions are
                #  performed on each double-octet (one per octet)
                i += 2           